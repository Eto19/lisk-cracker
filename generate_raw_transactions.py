from lib_ed import *

import nacl.bindings
import json
import argparse

"""
USED TO GENERATE RAW JSON TRANSACTIONS FROM RESULTS.TXT FILE
SENDS FULL AMOUNT TO RECIPIENT ADDRESS

THE TRANSACTIONS ARE NOT BROADCASTED TO NETWORK
"""

def load_results(filename):
    list_results = []
    
    with open(filename) as csv_file1:
        csv_reader1 = csv.reader(csv_file1, delimiter=',')
        for row1 in csv_reader1:
            list_results.append((row1[0],row1[1],row1[2],int(float(row1[3])*10**8)-10000000))

    return list_results

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('--input-results-file', dest="input_file", default="results.txt", help="Results file generated by main program. Default: results.txt")
    parser.add_argument('--recipient-address', dest="recipient_address", default="123456789L", help="Recipient address for transactions. Default: 123456789L")
    parser.add_argument('--output-transactions-file', dest="output_file", default='transactions.txt', help="Output raw transactions to file, one per line, json. Default: transactions.txt")
    args = parser.parse_args()

    # load result file
    array_addresses = load_results(args.input_file)
    print(array_addresses)

    # prepare transactions
    from datetime import datetime, timezone
    genesis_timestamp = 1464109200
    tx_timestamp = math.floor(datetime.now(timezone.utc).timestamp()-genesis_timestamp)

    raw_transactions = []

    for target in array_addresses:
        raw_transactions.append({"type":0,"amount":str(target[3]),"fee":"10000000","recipientId":str(args.recipient_address),"timestamp":tx_timestamp,"asset":{},"senderPublicKey":str(target[1]),"signature":"","id":""})

    # sign transactions
    tx_i = 0
    signed_transactions = []

    for transaction in raw_transactions:
        found = False
        for n_test in range(0, 512):
            transaction["signature"] = ""
            transaction["id"] = ""
            transaction["timestamp"] = math.floor(datetime.now(timezone.utc).timestamp()-genesis_timestamp)
            if int(array_addresses[tx_i][3]) <= 10000000:
                print()
                print('Balance too low for address ' + str(array_addresses[tx_i][0]) + ' ! Exiting...')
                exit()

            tx_hash  = get_transaction_hash(transaction)

            # Sign the transaction
            pk_x = binascii.unhexlify(array_addresses[tx_i][1])
            sk_x = array_addresses[tx_i][2]
            sk_x_2 = int_to_hex((l-hex_to_int(array_addresses[tx_i][2]))%l)
            sig = signature_unsafe(tx_hash, sk_x, pk_x)
            sig_2 = signature_unsafe(tx_hash, sk_x_2, pk_x)

            # Verify signature using nacl library
            try:
                nacl.bindings.crypto_sign_open(sig+tx_hash, pk_x)
                signed_transactions.append(transaction)

                transaction["signature"] = str(binascii.hexlify(sig).decode('utf-8'))
                tx_id = get_transaction_id(transaction)
                transaction["id"] = str(tx_id)
                found = True
                break
            except:
                pass
            try:
                nacl.bindings.crypto_sign_open(sig_2+tx_hash, pk_x)
                signed_transactions.append(transaction)
                  
                transaction["signature"] = str(binascii.hexlify(sig_2).decode('utf-8'))
                tx_id = get_transaction_id(transaction)
                transaction["id"] = str(tx_id)

                found = True
                break
            except:
                pass
        if not found:
            print('error in signing process')
        tx_i += 1

    # output
    res_file = open(str(args.output_file),"w+") 
    for transaction in signed_transactions:
        print(json.dumps(transaction))
        res_file.write(json.dumps(transaction) + "\n") 
    res_file.close() 
